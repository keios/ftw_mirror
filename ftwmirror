#!/bin/bash
#
# this file is licenced under the
#
# DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
#                    Version 2, December 2004
#
# Copyright (C) 2004 Sam Hocevar <sam@hocevar.net>
#
# Everyone is permitted to copy and distribute verbatim or modified
# copies of this license document, and changing it is allowed as long
# as the name is changed.
#
#            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
#   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
#
#  0. You just DO WHAT THE FUCK YOU WANT TO.
#
#

# set to your liking
WATCH_DIR=/home/keios/test/FTWMirror
TARGET_DIR=/home/keios/test/ftw_mirror/data

# this will be read (and cleared) by the frontend
ERROR_MSG=/home/keios/test/ftw_mirror/error.msg

# this is cheap and only somewhat effective. webservers generally interpret files by mimetype, not by extension,
# so you really shouldn't frolic that you're safe from malicious attackers. 'malicious_php_code.jpg' can still ruin your day
EXCLUDE_TYPES="xhtml xml html htm php php4 php5 ph3 ph4 ph5 phtml phtm pl cgi"

# for setting permissions on the file afterwards - not a umask
MIRRORED_FILEPERM="0440"
# should be set to the user and group your webserver uses
MIRRORED_USER="keios"
MIRRORED_GROUP="users"

# use symlinks instead of copying. will only work if $WATCH_DIR and $TARGET_DIR are on the same partition. could fail because of access rights
USE_SYMLINKS=true

# leave these alone
ACTION=""
DATE=""
FILE_HANDLE=""
FILETYPE=""

set -u
# build a suitable regexp
EXCLUDE_TYPES="^${EXCLUDE_TYPES// /\$|^}\$"
# set up error logging
[ -f "$ERROR_MSG" ] || touch "$ERROR_MSG" && chown "$MIRRORED_USER":"$MIRRORED_GROUP" "$ERROR_MSG"

# main loop
inotifywait -q -m -r --format '%e %f' -e create -e delete -e close_write -e moved_to -e moved_from "$WATCH_DIR" | while read LINE; do
    # awk is slow, but i don't care. send me a pull request if you've a better option
    ACTION=$( echo "$LINE" | awk '{print $1;}' )
    # print lines 2 to n (for filenames with spaces) and rebuild for output on the same line
    FILE_HANDLE=$( echo "$LINE" | awk '{for (i=1; i<=NF-1; i++) $i = $(i+1); NF-=1; print}' )

    case $ACTION in
        CREATE,ISDIR)
            # write an error message if somebody tries to upload a directory
            DATE=$(date +%F/%T)
            echo -e "$DATE: \"$FILE_HANDLE\" is a directory. this service is for files only.\r" >> "$ERROR_MSG"
            # for good measure
            rm -rf "$WATCH_DIR/$FILE_HANDLE"
        ;;
        DELETE|MOVED_FROM)
            rm -f "$TARGET_DIR/$FILE_HANDLE"
        ;;
        CLOSE_WRITE*|MOVED_TO)
            FILETYPE=$(echo "${FILE_HANDLE##*.}" | tr [:upper:] [:lower:])
            if [[ $FILETYPE =~ $EXCLUDE_TYPES ]]; then
                # write an error message if somebody tries to upload an undesirable filetype
                DATE=$(date +%F/%T)
                echo -e "$DATE: \"$FILE_HANDLE\" is a \"$FILETYPE\" file. this service does not accept such.\r" >> "$ERROR_MSG"
                # kill it with fire or the nearest equivalent
                rm -f "$WATCH_DIR/$FILE_HANDLE"
            else
                if ($USE_SYMLINKS); then
                    # ln breaks if the link target includes whitespace
                    LINKSOURCE="$WATCH_DIR/$FILE_HANDLE"
                    LINKTARGET="$TARGET_DIR/$FILE_HANDLE"
                    # thus, escape all the spaces!
                    LINKSOURCE=$( echo -e "$LINKSOURCE" | awk 'BEGIN {FS = "\n" } { printf "\"%s\" ", $1 }' | sed -e s#\"\"## )
                    LINKTARGET=$( echo -e "$LINKTARGET" | awk 'BEGIN {FS = "\n" } { printf "\"%s\" ", $1 }' | sed -e s#\"\"## )

                    eval ln -sf "$LINKSOURCE" "$LINKTARGET"
                else
                    DISKFREE=$( df --output=avail "$TARGET_DIR" | tail -1 )
                    FILESIZE=$( stat -c%s "$WATCH_DIR/$FILE_HANDLE")
                    echo $DISKFREE"==="$FILESIZE
                    if [[ $DISKFREE -gt $FILESIZE ]]; then
                        cp -f "$WATCH_DIR/$FILE_HANDLE" "$TARGET_DIR/$FILE_HANDLE"
                        chmod $MIRRORED_FILEPERM "$TARGET_DIR/$FILE_HANDLE"
                        chown "$MIRRORED_USER":"$MIRRORED_GROUP" "$TARGET_DIR/$FILE_HANDLE"
                    fi
                fi
            fi
        ;;
        *)
        ;;
    esac

    # just because
    ACTION=""
    FILE_HANDLE=""
    LINE=""

done

exit 0
